<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Felix Dilke">
  <title>Generating Mazes in Idris</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./reveal.js/css/reveal.css">
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="./reveal.js/css/theme/moon.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? './reveal.js/css/print/pdf.css' : './reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="./reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
  <h1 class="title">Generating Mazes in Idris</h1>
  <p class="author">Felix Dilke</p>
</section>

<section class="slide level2">

<p><img src="images/dark-labyrinth.jpg" /><br />
</p>
</section>
<section id="generating-mazes" class="slide level2">
<h2>Generating mazes</h2>
<ul>
<li><p>I've been trying to learn Idris, a somewhat bleeding-edge programming language which is like Haskell but more so</p></li>
<li><p>I (wrongly) decided I understood it well enough to try writing a program to generate mazes</p></li>
<li><p>Counterintuitively, the hard things turned out to be simple, but the simple things were hard...</p></li>
</ul>

</section>
<section id="the-mission-should-you-choose-to-accept-it" class="slide level2">
<h2>The mission, should you choose to accept it</h2>
<p>The idea is that the maze will look like this:</p>
<p><img src="images/my-maze.png" /><br />
</p>
<p>I also decided to output this in text mode using quarter-square graphics.</p>
<p>Once the basic algorithm is done, it can output bigger and badder mazes.</p>

</section>
<section id="how-do-you-generate-a-maze-anyway" class="slide level2">
<h2>How do you generate a maze, anyway?</h2>
<p>Abstracting away all the irrelevant details, the underlying skeleton of the maze is something like this:</p>
<p><img src="images/skeleton-maze.jpg" id="id" class="class" width="200" height="200" /><br />
This is a rectangular grid of cells where we've connected just enough pairs of adjacent cells for the whole graph to be one piece,</p>
<p>or, equivalently:</p>
<p>as many pairs of adjacent cells as we can without forming a circuit.</p>

</section>
<section id="compsci-description-of-the-problem" class="slide level2">
<h2>CompSci description of the problem</h2>
<p>Given a rectangular grid of cells, make it into a graph by connecting every pair of adjacent cells with an edge.</p>
<p>We have to find a <em>spanning forest</em> of this graph.</p>
<p>This is pretty simple: you just accumulate a list of edges, only adding ones that don't create a circuit.</p>

</section>
<section id="but-heres-what-happens-if-you-do-that" class="slide level2">
<h2>But, here's what happens if you do that</h2>
<p><img src="images/boring-maze.jpg" id="id" class="class" width="200" height="200" /><br />
which is not an acceptable solution because it's the same boring maze each time.</p>
<p>We have to introduce randomness, i.e. present the edges in a random order.</p>
<p>Absurdly, it turned out this was the hardest part of the project, for reasons you may find amusing even if languages like Idris are not your bag.</p>

</section>
<section id="so-im-going-to-skate-lightly-over-the-actual-spanning-forest-algorithm" class="slide level2">
<h2>So I'm going to skate lightly over the actual Spanning Forest algorithm</h2>
<p>but here it is, anyway:</p>
<p><img src="images/spanning-forest.png" id="id" class="class" width="400" height="300" /><br />
This was hard too, but in a good way.</p>
<p>It's basically just a fold - accumulating a list of edges - but you have to efficiently keep track of which cells are connected. You also have to use the right data structures in Idris, and figure out how to test-drive it... all of which took a while.</p>

</section>
<section id="but-then-my-mazes-kept-looking-like-this" class="slide level2">
<h2>But then, my mazes kept looking like this:</h2>
<p><img src="images/mangled-maze.jpg" id="id" class="class" width="400" height="300" /><br />
After staring at this for hours, I realized that</p>
<ol type="1">
<li><p>the bottom and right edges were mangled because of a fencepost error, which was easily fixed</p></li>
<li><p>the randomizer wasn't working properly.</p></li>
</ol>
<p>But all it had to do was shuffle the list of edges, i.e. generate a uniformly random permutation.</p>

</section>
<section id="why-is-randomness-so-hard" class="slide level2">
<h2>Why is randomness so hard?</h2>
<p><img src="images/roulette-wheel.png" id="id" class="class" width="400" height="300" /><br />
It isn't functional! A method that returns random numbers isn't permissible in Idris because it can return a different value on every call, violating the semantics. Same goes for a function that returns the date and time.</p>
<p>So you have to generate random numbers in the context of a special monad, and use the Effects library to get it to interoperate with all the other monads you have to use for anything else that is not strictly functional.</p>
<p>Yes, I know this is why not everyone would want to use languages like Idris.</p>
<p>Also, it turned out there was a <em>bug</em> in the run time library which was interacting adversely with the perhaps overcomplicated &quot;Godel numbering scheme for permutations&quot; I had decided to use, which was fun to implement but not, as it turned out, practical.</p>

</section>
<section id="why-is-randomness-so-hard-continued" class="slide level2">
<h2>Why is randomness so hard? (continued)</h2>
<p>Instead, the solution was to look up &quot;generating uniformly random permutations&quot; on Wikipedia which tells you to use the Knuth shuffle.</p>
<p>But even that is hard! The algorithm involves swapping successive pairs of elements in an array to generate the permutation by composing transpositions. And that's non-functional - arrays are not mutable in Idris.</p>
<p>I managed to write a recursive algorithm to do it by disassembling and recombining the array, but it was very slow for mazes of any size.</p>
<p>I searched the web to find out how Haskellers get round this problem, and it turns out they do it by using a special hack to mutate the array, because Haskell is a more mature (and possibly more pragmatic) language than Idris.</p>
<p>I conjecture that generating random permutations in an efficient yet functionally pure way should be achievable, but for now, this seems to be the stuff of CompSci PhD theses.</p>
<p>Meanwhile, here is my not-too-chronically-slow compromise solution:</p>
<p><img src="images/shuffle-algorithm.png" id="id" class="class" width="400" height="300" />Â </p>

</section>
<section id="which-finally-makes-it-possible-..." class="slide level2">
<h2>... which finally makes it possible ...</h2>
<p>... to generate mazes in Idris</p>
<p>(switch to command line for demo)</p>
</section>
<section><section id="thank-you" class="titleslide slide level1"><h1>THANK YOU</h1></section></section>
    </div>
  </div>

  <script src="./reveal.js/lib/js/head.min.js"></script>
  <script src="./reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Transition style
        transition: 'cube', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: './reveal.js/plugin/zoom-js/zoom.js', async: true },
              { src: './reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
